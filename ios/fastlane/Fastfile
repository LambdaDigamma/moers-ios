# frozen_string_literal: true
require 'base64'

default_platform(:ios)

# Configuration
APP_IDENTIFIERS = [
  "de.okfn.niederrhein.Moers",
  "de.okfn.niederrhein.Moers.widgets",
  "de.okfn.niederrhein.Moers.Intent-Extensions"
].freeze

DEVICES = {
  "Lennarts iPhone 8" => "e3f6fe313610d72f847e010d17af266b64781acf",
  "Lennarts iPhone XS" => "00008020-000C584C2690003A",
  "Lennarts iPad Pro" => "00008103-001C34490CF1001E",
  "Lennarts iPhone" => "00008120-000E7C8C0E38C01E"
}.freeze

INFO_PLIST_PATHS = [
  "Moers/Config/Info.plist",
  "Intent Extensions/Info.plist",
  "Widgets/Resources/Info.plist",
  "Watch Extension/Info.plist",
  "Watch/Info.plist",
  "Moers Unit Tests/Info.plist"
].freeze

platform :ios do
  # Helper Methods
  def update_version_in_plists(version)
    INFO_PLIST_PATHS.each do |path|
      set_info_plist_value(
        path: path,
        key: "CFBundleShortVersionString",
        value: version
      )
    end
  end

  def commit_version_changes(version)
    git_commit(
      path: INFO_PLIST_PATHS,
      message: "Mein Moers Version #{version} ðŸš€"
    )
  end

  desc "Increment version number"
  lane :increment do |options|
    UI.user_error!("Version parameter is required") unless options[:version]
    
    update_version_in_plists(options[:version])
    commit_version_changes(options[:version])
  end

  desc "Increment version number (patch, minor, major)"
  lane :increment_version do |options|
    UI.user_error!("Specify version type: patch, minor, or major") unless options[:type]

    # Read current version from the first Info.plist
    current_version = get_info_plist_value(
      path: INFO_PLIST_PATHS.first,
      key: "CFBundleShortVersionString"
    )

    # Parse version components
    major, minor, patch = current_version.split('.').map(&:to_i)

    case options[:type]
    when "patch"
      patch += 1
    when "minor"
      minor += 1
      patch = 0
    when "major"
      major += 1
      minor = 0
      patch = 0
    else
      UI.user_error!("Invalid version type: #{options[:type]}")
    end

    new_version = "#{major}.#{minor}.#{patch}"

    UI.message("Updating version to #{new_version}")

    # Update all Info.plist files with the new version
    update_version_in_plists(new_version)
  end

  desc "Increment build number across all targets"
  lane :increment_build do
    targets = [
      'Moers',
      'Moers Unit Tests',
      'MoersUITests',
      'WidgetsExtension',
      'Intent Extensions'
    ]

    targets.each do |target|
      increment_build_number_in_plist(target: target)
    end
  end

  desc "Build the iOS app for release"
  lane :build_release do |options|
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

    build_app(
      scheme: "Moers",
      configuration: "Release (Production)",
      verbose: true
    )
  end

  desc "Upload to TestFlight / ASC"
  lane :upload_release do
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

    deliver(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      skip_app_version_update: true,
      force: true,
      run_precheck_before_submit: false
    )
  end

  lane :upload do |options|
    require 'base64'

    username = "lambdadigamma"
    token = ENV['GITHUB_TOKEN']

    encoded_credentials = Base64.strict_encode64("#{username}:#{token}")

    load_asc_api_key
    setup_ci if ENV['CI']
    match(
      type: 'appstore',
      verbose: true,
      git_basic_authorization: encoded_credentials
    )
    build_release
    upload_release

  end

  # ------------ Code Signing ------------

  desc "Load ASC API Key information to use in subsequent lanes"
  lane :load_asc_api_key do
    app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_KEY"],
      is_key_content_base64: true,
      in_house: false # detecting this via ASC private key not currently supported
    )
  end

  # ------------ Screenshots ------------

  desc "Upload metadata to App Store Connect"
  lane :upload_metadata do
    deliver(
      skip_metadata: false,
      skip_screenshots: true,
      force: true
    )
  end

  desc "Capture and frame screenshots"
  lane :screenshots do
    capture_screenshots(
      devices: [
        "iPad Pro (12.9-inch) (2nd generation)",
        "iPad Pro (12.9-inch) (3rd generation)"
      ]
    )
    frame_screenshots
  end

  desc "Upload screenshots to App Store Connect"
  lane :upload_screenshots do
    deliver(
      app_version: "3.2.1",
      skip_binary_upload: true,
      overwrite_screenshots: true
    )
  end

  desc "Take screenshots and upload to App Store Connect"
  lane :deliver_screenshots do
    screenshots
    deliver(skip_binary_upload: true)
  end

  # ------------ Old ------------

  desc "Release a new version of Mein Moers"
  lane :release do |options|
    UI.user_error!("Version parameter is required") unless options[:version]

    ensure_git_status_clean
    ensure_git_branch(branch: 'master')

    begin
      increment_build
      increment(version: options[:version])

      add_git_tag(
        grouping: "ios",
        includes_lane: false
      )

      match(type: "appstore")
      gym(scheme: "Moers")
      pilot(skip_waiting_for_build_processing: true)

    rescue => exception
      UI.error("Release failed: #{exception.message}")
      raise exception
    end
  end

  desc "Sync code signing for development and app store"
  lane :signing do
    register_devices(
      team_id: "77N8D7LGCZ",
      devices: DEVICES
    )

    ["development", "appstore"].each do |type|
      sync_code_signing(
        type: type,
        force_for_new_devices: type == "development",
        app_identifier: APP_IDENTIFIERS
      )
    end
  end

  # Error Handling
  error do |lane, exception|
    UI.error("Lane '#{lane}' failed with error: #{exception.message}")
  end
end